// Package dbo contains the types for schema 'public'.
package dbo

// Code generated by xo. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/csv"
	"errors"
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/lib/pq"
)

// Event represents a row from '"public"."event"'.
type Event struct {
	ID        int64     `json:"id"`         // id
	CreatedAt time.Time `json:"created_at"` // created_at
	Name      string    `json:"name"`       // name

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Event exists in the database.
func (e *Event) Exists() bool {
	return e._exists
}

// Deleted provides information if the Event has been deleted from the database.
func (e *Event) Deleted() bool {
	return e._deleted
}

// Insert inserts the Event to the database.
func (e *Event) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if e._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO "public"."event" (` +
		`"created_at", "name"` +
		`) VALUES (` +
		`$1, $2` +
		`) RETURNING "id"`

	// run query
	XOLog(sqlstr, e.CreatedAt, e.Name)
	err = db.QueryRow(sqlstr, e.CreatedAt, e.Name).Scan(&e.ID)
	if err != nil {
		return err
	}

	// set existence
	e._exists = true

	return nil
}

// Update updates the Event in the database.
func (e *Event) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !e._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if e._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE "public"."event" SET (` +
		`"created_at", "name"` +
		`) = ( ` +
		`$1, $2` +
		`) WHERE "id" = $3`

	// run query
	XOLog(sqlstr, e.CreatedAt, e.Name, e.ID)
	_, err = db.Exec(sqlstr, e.CreatedAt, e.Name, e.ID)
	return err
}

// Save saves the Event to the database.
func (e *Event) Save(db XODB) error {
	if e.Exists() {
		return e.Update(db)
	}

	return e.Insert(db)
}

// Upsert performs an upsert for Event.
//
// NOTE: PostgreSQL 9.5+ only
func (e *Event) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if e._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "public"."event" (` +
		`"id", "created_at", "name"` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) ON CONFLICT ("id") DO UPDATE SET (` +
		`"id", "created_at", "name"` +
		`) = (` +
		`EXCLUDED."id", EXCLUDED."created_at", EXCLUDED."name"` +
		`)`

	// run query
	XOLog(sqlstr, e.ID, e.CreatedAt, e.Name)
	_, err = db.Exec(sqlstr, e.ID, e.CreatedAt, e.Name)
	if err != nil {
		return err
	}

	// set existence
	e._exists = true

	return nil
}

// Delete deletes the Event from the database.
func (e *Event) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !e._exists {
		return nil
	}

	// if deleted, bail
	if e._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "public"."event" WHERE "id" = $1`

	// run query
	XOLog(sqlstr, e.ID)
	_, err = db.Exec(sqlstr, e.ID)
	if err != nil {
		return err
	}

	// set deleted
	e._deleted = true

	return nil
}

// Flow represents a row from '"public"."flow"'.
type Flow struct {
	ID        int64     `json:"id"`         // id
	CreatedAt time.Time `json:"created_at"` // created_at
	Name      string    `json:"name"`       // name

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Flow exists in the database.
func (f *Flow) Exists() bool {
	return f._exists
}

// Deleted provides information if the Flow has been deleted from the database.
func (f *Flow) Deleted() bool {
	return f._deleted
}

// Insert inserts the Flow to the database.
func (f *Flow) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if f._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO "public"."flow" (` +
		`"created_at", "name"` +
		`) VALUES (` +
		`$1, $2` +
		`) RETURNING "id"`

	// run query
	XOLog(sqlstr, f.CreatedAt, f.Name)
	err = db.QueryRow(sqlstr, f.CreatedAt, f.Name).Scan(&f.ID)
	if err != nil {
		return err
	}

	// set existence
	f._exists = true

	return nil
}

// Update updates the Flow in the database.
func (f *Flow) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !f._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if f._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE "public"."flow" SET (` +
		`"created_at", "name"` +
		`) = ( ` +
		`$1, $2` +
		`) WHERE "id" = $3`

	// run query
	XOLog(sqlstr, f.CreatedAt, f.Name, f.ID)
	_, err = db.Exec(sqlstr, f.CreatedAt, f.Name, f.ID)
	return err
}

// Save saves the Flow to the database.
func (f *Flow) Save(db XODB) error {
	if f.Exists() {
		return f.Update(db)
	}

	return f.Insert(db)
}

// Upsert performs an upsert for Flow.
//
// NOTE: PostgreSQL 9.5+ only
func (f *Flow) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if f._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "public"."flow" (` +
		`"id", "created_at", "name"` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) ON CONFLICT ("id") DO UPDATE SET (` +
		`"id", "created_at", "name"` +
		`) = (` +
		`EXCLUDED."id", EXCLUDED."created_at", EXCLUDED."name"` +
		`)`

	// run query
	XOLog(sqlstr, f.ID, f.CreatedAt, f.Name)
	_, err = db.Exec(sqlstr, f.ID, f.CreatedAt, f.Name)
	if err != nil {
		return err
	}

	// set existence
	f._exists = true

	return nil
}

// Delete deletes the Flow from the database.
func (f *Flow) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !f._exists {
		return nil
	}

	// if deleted, bail
	if f._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "public"."flow" WHERE "id" = $1`

	// run query
	XOLog(sqlstr, f.ID)
	_, err = db.Exec(sqlstr, f.ID)
	if err != nil {
		return err
	}

	// set deleted
	f._deleted = true

	return nil
}

// History represents a row from '"public"."history"'.
type History struct {
	ID             int64     `json:"id"`              // id
	CreatedAt      time.Time `json:"created_at"`      // created_at
	EventID        int64     `json:"event_id"`        // event_id
	EventMsgid     string    `json:"event_msgid"`     // event_msgid
	EventTimestamp time.Time `json:"event_timestamp"` // event_timestamp
	FlowID         int64     `json:"flow_id"`         // flow_id
	FromServiceID  int64     `json:"from_service_id"` // from_service_id
	LastServiceID  int64     `json:"last_service_id"` // last_service_id
	Repeat         int       `json:"repeat"`          // repeat
	JSONHeaders    string    `json:"json_headers"`    // json_headers
	Body           []byte    `json:"body"`            // body

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the History exists in the database.
func (h *History) Exists() bool {
	return h._exists
}

// Deleted provides information if the History has been deleted from the database.
func (h *History) Deleted() bool {
	return h._deleted
}

// Insert inserts the History to the database.
func (h *History) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if h._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO "public"."history" (` +
		`"created_at", "event_id", "event_msgid", "event_timestamp", "flow_id", "from_service_id", "last_service_id", "repeat", "json_headers", "body"` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`) RETURNING "id"`

	// run query
	XOLog(sqlstr, h.CreatedAt, h.EventID, h.EventMsgid, h.EventTimestamp, h.FlowID, h.FromServiceID, h.LastServiceID, h.Repeat, h.JSONHeaders, h.Body)
	err = db.QueryRow(sqlstr, h.CreatedAt, h.EventID, h.EventMsgid, h.EventTimestamp, h.FlowID, h.FromServiceID, h.LastServiceID, h.Repeat, h.JSONHeaders, h.Body).Scan(&h.ID)
	if err != nil {
		return err
	}

	// set existence
	h._exists = true

	return nil
}

// Update updates the History in the database.
func (h *History) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !h._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if h._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE "public"."history" SET (` +
		`"created_at", "event_id", "event_msgid", "event_timestamp", "flow_id", "from_service_id", "last_service_id", "repeat", "json_headers", "body"` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`) WHERE "id" = $11`

	// run query
	XOLog(sqlstr, h.CreatedAt, h.EventID, h.EventMsgid, h.EventTimestamp, h.FlowID, h.FromServiceID, h.LastServiceID, h.Repeat, h.JSONHeaders, h.Body, h.ID)
	_, err = db.Exec(sqlstr, h.CreatedAt, h.EventID, h.EventMsgid, h.EventTimestamp, h.FlowID, h.FromServiceID, h.LastServiceID, h.Repeat, h.JSONHeaders, h.Body, h.ID)
	return err
}

// Save saves the History to the database.
func (h *History) Save(db XODB) error {
	if h.Exists() {
		return h.Update(db)
	}

	return h.Insert(db)
}

// Upsert performs an upsert for History.
//
// NOTE: PostgreSQL 9.5+ only
func (h *History) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if h._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "public"."history" (` +
		`"id", "created_at", "event_id", "event_msgid", "event_timestamp", "flow_id", "from_service_id", "last_service_id", "repeat", "json_headers", "body"` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11` +
		`) ON CONFLICT ("id") DO UPDATE SET (` +
		`"id", "created_at", "event_id", "event_msgid", "event_timestamp", "flow_id", "from_service_id", "last_service_id", "repeat", "json_headers", "body"` +
		`) = (` +
		`EXCLUDED."id", EXCLUDED."created_at", EXCLUDED."event_id", EXCLUDED."event_msgid", EXCLUDED."event_timestamp", EXCLUDED."flow_id", EXCLUDED."from_service_id", EXCLUDED."last_service_id", EXCLUDED."repeat", EXCLUDED."json_headers", EXCLUDED."body"` +
		`)`

	// run query
	XOLog(sqlstr, h.ID, h.CreatedAt, h.EventID, h.EventMsgid, h.EventTimestamp, h.FlowID, h.FromServiceID, h.LastServiceID, h.Repeat, h.JSONHeaders, h.Body)
	_, err = db.Exec(sqlstr, h.ID, h.CreatedAt, h.EventID, h.EventMsgid, h.EventTimestamp, h.FlowID, h.FromServiceID, h.LastServiceID, h.Repeat, h.JSONHeaders, h.Body)
	if err != nil {
		return err
	}

	// set existence
	h._exists = true

	return nil
}

// Delete deletes the History from the database.
func (h *History) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !h._exists {
		return nil
	}

	// if deleted, bail
	if h._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "public"."history" WHERE "id" = $1`

	// run query
	XOLog(sqlstr, h.ID)
	_, err = db.Exec(sqlstr, h.ID)
	if err != nil {
		return err
	}

	// set deleted
	h._deleted = true

	return nil
}

// HistoryWithDetail represents a row from '"public"."history_with_details"'.
type HistoryWithDetail struct {
	ID                   sql.NullInt64  `json:"id"`                      // id
	CreatedAt            pq.NullTime    `json:"created_at"`              // created_at
	EventID              sql.NullInt64  `json:"event_id"`                // event_id
	EventMsgid           sql.NullString `json:"event_msgid"`             // event_msgid
	EventTimestamp       pq.NullTime    `json:"event_timestamp"`         // event_timestamp
	FlowID               sql.NullInt64  `json:"flow_id"`                 // flow_id
	FromServiceID        sql.NullInt64  `json:"from_service_id"`         // from_service_id
	LastServiceID        sql.NullInt64  `json:"last_service_id"`         // last_service_id
	Repeat               sql.NullInt64  `json:"repeat"`                  // repeat
	JSONHeaders          sql.NullString `json:"json_headers"`            // json_headers
	Body                 []byte         `json:"body"`                    // body
	EventName            sql.NullString `json:"event_name"`              // event_name
	EventCreatedAt       pq.NullTime    `json:"event_created_at"`        // event_created_at
	FlowName             sql.NullString `json:"flow_name"`               // flow_name
	FlowCreatedAt        pq.NullTime    `json:"flow_created_at"`         // flow_created_at
	FromServiceName      sql.NullString `json:"from_service_name"`       // from_service_name
	FromServiceCreatedAt pq.NullTime    `json:"from_service_created_at"` // from_service_created_at
	LastServiceName      sql.NullString `json:"last_service_name"`       // last_service_name
	LastServiceCreatedAt pq.NullTime    `json:"last_service_created_at"` // last_service_created_at
}

// Service represents a row from '"public"."service"'.
type Service struct {
	ID        int64     `json:"id"`         // id
	CreatedAt time.Time `json:"created_at"` // created_at
	Name      string    `json:"name"`       // name

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Service exists in the database.
func (s *Service) Exists() bool {
	return s._exists
}

// Deleted provides information if the Service has been deleted from the database.
func (s *Service) Deleted() bool {
	return s._deleted
}

// Insert inserts the Service to the database.
func (s *Service) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if s._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO "public"."service" (` +
		`"created_at", "name"` +
		`) VALUES (` +
		`$1, $2` +
		`) RETURNING "id"`

	// run query
	XOLog(sqlstr, s.CreatedAt, s.Name)
	err = db.QueryRow(sqlstr, s.CreatedAt, s.Name).Scan(&s.ID)
	if err != nil {
		return err
	}

	// set existence
	s._exists = true

	return nil
}

// Update updates the Service in the database.
func (s *Service) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !s._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if s._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE "public"."service" SET (` +
		`"created_at", "name"` +
		`) = ( ` +
		`$1, $2` +
		`) WHERE "id" = $3`

	// run query
	XOLog(sqlstr, s.CreatedAt, s.Name, s.ID)
	_, err = db.Exec(sqlstr, s.CreatedAt, s.Name, s.ID)
	return err
}

// Save saves the Service to the database.
func (s *Service) Save(db XODB) error {
	if s.Exists() {
		return s.Update(db)
	}

	return s.Insert(db)
}

// Upsert performs an upsert for Service.
//
// NOTE: PostgreSQL 9.5+ only
func (s *Service) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if s._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "public"."service" (` +
		`"id", "created_at", "name"` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) ON CONFLICT ("id") DO UPDATE SET (` +
		`"id", "created_at", "name"` +
		`) = (` +
		`EXCLUDED."id", EXCLUDED."created_at", EXCLUDED."name"` +
		`)`

	// run query
	XOLog(sqlstr, s.ID, s.CreatedAt, s.Name)
	_, err = db.Exec(sqlstr, s.ID, s.CreatedAt, s.Name)
	if err != nil {
		return err
	}

	// set existence
	s._exists = true

	return nil
}

// Delete deletes the Service from the database.
func (s *Service) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !s._exists {
		return nil
	}

	// if deleted, bail
	if s._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "public"."service" WHERE "id" = $1`

	// run query
	XOLog(sqlstr, s.ID)
	_, err = db.Exec(sqlstr, s.ID)
	if err != nil {
		return err
	}

	// set deleted
	s._deleted = true

	return nil
}

// Event returns the Event associated with the History's EventID (event_id).
//
// Generated from foreign key 'history_event_id_fkey'.
func (h *History) Event(db XODB) (*Event, error) {
	return EventByID(db, h.EventID)
}

// Flow returns the Flow associated with the History's FlowID (flow_id).
//
// Generated from foreign key 'history_flow_id_fkey'.
func (h *History) Flow(db XODB) (*Flow, error) {
	return FlowByID(db, h.FlowID)
}

// ServiceByFromServiceID returns the Service associated with the History's FromServiceID (from_service_id).
//
// Generated from foreign key 'history_from_service_id_fkey'.
func (h *History) ServiceByFromServiceID(db XODB) (*Service, error) {
	return ServiceByID(db, h.FromServiceID)
}

// ServiceByLastServiceID returns the Service associated with the History's LastServiceID (last_service_id).
//
// Generated from foreign key 'history_last_service_id_fkey'.
func (h *History) ServiceByLastServiceID(db XODB) (*Service, error) {
	return ServiceByID(db, h.LastServiceID)
}

// EventByName retrieves a row from '"public"."event"' as a Event.
//
// Generated from index 'event_name_key'.
func EventByName(db XODB, name string) (*Event, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "created_at", "name" ` +
		`FROM "public"."event" ` +
		`WHERE "name" = $1`

	// run query
	XOLog(sqlstr, name)
	e := Event{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, name).Scan(&e.ID, &e.CreatedAt, &e.Name)
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// EventByID retrieves a row from '"public"."event"' as a Event.
//
// Generated from index 'event_pkey'.
func EventByID(db XODB, id int64) (*Event, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "created_at", "name" ` +
		`FROM "public"."event" ` +
		`WHERE "id" = $1`

	// run query
	XOLog(sqlstr, id)
	e := Event{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&e.ID, &e.CreatedAt, &e.Name)
	if err != nil {
		return nil, err
	}

	return &e, nil
}

// FlowByName retrieves a row from '"public"."flow"' as a Flow.
//
// Generated from index 'flow_name_key'.
func FlowByName(db XODB, name string) (*Flow, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "created_at", "name" ` +
		`FROM "public"."flow" ` +
		`WHERE "name" = $1`

	// run query
	XOLog(sqlstr, name)
	f := Flow{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, name).Scan(&f.ID, &f.CreatedAt, &f.Name)
	if err != nil {
		return nil, err
	}

	return &f, nil
}

// FlowByID retrieves a row from '"public"."flow"' as a Flow.
//
// Generated from index 'flow_pkey'.
func FlowByID(db XODB, id int64) (*Flow, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "created_at", "name" ` +
		`FROM "public"."flow" ` +
		`WHERE "id" = $1`

	// run query
	XOLog(sqlstr, id)
	f := Flow{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&f.ID, &f.CreatedAt, &f.Name)
	if err != nil {
		return nil, err
	}

	return &f, nil
}

// HistoriesByEventMsgid retrieves a row from '"public"."history"' as a History.
//
// Generated from index 'history_event_msgid_key'.
func HistoriesByEventMsgid(db XODB, eventMsgid string) ([]*History, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "created_at", "event_id", "event_msgid", "event_timestamp", "flow_id", "from_service_id", "last_service_id", "repeat", "json_headers", "body" ` +
		`FROM "public"."history" ` +
		`WHERE "event_msgid" = $1`

	// run query
	XOLog(sqlstr, eventMsgid)
	q, err := db.Query(sqlstr, eventMsgid)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*History{}
	for q.Next() {
		h := History{
			_exists: true,
		}

		// scan
		err = q.Scan(&h.ID, &h.CreatedAt, &h.EventID, &h.EventMsgid, &h.EventTimestamp, &h.FlowID, &h.FromServiceID, &h.LastServiceID, &h.Repeat, &h.JSONHeaders, &h.Body)
		if err != nil {
			return nil, err
		}

		res = append(res, &h)
	}

	return res, nil
}

// HistoryByID retrieves a row from '"public"."history"' as a History.
//
// Generated from index 'history_pkey'.
func HistoryByID(db XODB, id int64) (*History, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "created_at", "event_id", "event_msgid", "event_timestamp", "flow_id", "from_service_id", "last_service_id", "repeat", "json_headers", "body" ` +
		`FROM "public"."history" ` +
		`WHERE "id" = $1`

	// run query
	XOLog(sqlstr, id)
	h := History{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&h.ID, &h.CreatedAt, &h.EventID, &h.EventMsgid, &h.EventTimestamp, &h.FlowID, &h.FromServiceID, &h.LastServiceID, &h.Repeat, &h.JSONHeaders, &h.Body)
	if err != nil {
		return nil, err
	}

	return &h, nil
}

// ServiceByName retrieves a row from '"public"."service"' as a Service.
//
// Generated from index 'service_name_key'.
func ServiceByName(db XODB, name string) (*Service, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "created_at", "name" ` +
		`FROM "public"."service" ` +
		`WHERE "name" = $1`

	// run query
	XOLog(sqlstr, name)
	s := Service{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, name).Scan(&s.ID, &s.CreatedAt, &s.Name)
	if err != nil {
		return nil, err
	}

	return &s, nil
}

// ServiceByID retrieves a row from '"public"."service"' as a Service.
//
// Generated from index 'service_pkey'.
func ServiceByID(db XODB, id int64) (*Service, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "created_at", "name" ` +
		`FROM "public"."service" ` +
		`WHERE "id" = $1`

	// run query
	XOLog(sqlstr, id)
	s := Service{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&s.ID, &s.CreatedAt, &s.Name)
	if err != nil {
		return nil, err
	}

	return &s, nil
}

// XODB is the common interface for database operations that can be used with
// types from schema 'public'.
//
// This should work with database/sql.DB and database/sql.Tx.
type XODB interface {
	Exec(string, ...interface{}) (sql.Result, error)
	Query(string, ...interface{}) (*sql.Rows, error)
	QueryRow(string, ...interface{}) *sql.Row
}

// XOLog provides the log func used by generated queries.
var XOLog = func(string, ...interface{}) {}

// ScannerValuer is the common interface for types that implement both the
// database/sql.Scanner and sql/driver.Valuer interfaces.
type ScannerValuer interface {
	sql.Scanner
	driver.Valuer
}

// StringSlice is a slice of strings.
type StringSlice []string

// quoteEscapeRegex is the regex to match escaped characters in a string.
var quoteEscapeRegex = regexp.MustCompile(`([^\\]([\\]{2})*)\\"`)

// Scan satisfies the sql.Scanner interface for StringSlice.
func (ss *StringSlice) Scan(src interface{}) error {
	buf, ok := src.([]byte)
	if !ok {
		return errors.New("invalid StringSlice")
	}

	// change quote escapes for csv parser
	str := quoteEscapeRegex.ReplaceAllString(string(buf), `$1""`)
	str = strings.Replace(str, `\\`, `\`, -1)

	// remove braces
	str = str[1 : len(str)-1]

	// bail if only one
	if len(str) == 0 {
		*ss = StringSlice([]string{})
		return nil
	}

	// parse with csv reader
	cr := csv.NewReader(strings.NewReader(str))
	slice, err := cr.Read()
	if err != nil {
		fmt.Printf("exiting!: %v\n", err)
		return err
	}

	*ss = StringSlice(slice)

	return nil
}

// Value satisfies the driver.Valuer interface for StringSlice.
func (ss StringSlice) Value() (driver.Value, error) {
	v := make([]string, len(ss))
	for i, s := range ss {
		v[i] = `"` + strings.Replace(strings.Replace(s, `\`, `\\\`, -1), `"`, `\"`, -1) + `"`
	}
	return "{" + strings.Join(v, ",") + "}", nil
}

// Slice is a slice of ScannerValuers.
type Slice []ScannerValuer
