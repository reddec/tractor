// Package dbo contains the types for schema 'public'.
package dbo

// Code generated by xo. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/csv"
	"errors"
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/lib/pq"
)

// TractorEvent represents a row from '"public"."tractor_events"'.
type TractorEvent struct {
	ID          int64          `json:"id"`           // id
	Flow        string         `json:"flow"`         // flow
	EventID     sql.NullString `json:"event_id"`     // event_id
	Event       string         `json:"event"`        // event
	EventStamp  pq.NullTime    `json:"event_stamp"`  // event_stamp
	Source      sql.NullString `json:"source"`       // source
	Payload     []byte         `json:"payload"`      // payload
	CreatedAt   time.Time      `json:"created_at"`   // created_at
	FromService sql.NullString `json:"from_service"` // from_service
	LastService sql.NullString `json:"last_service"` // last_service
	LastError   sql.NullString `json:"last_error"`   // last_error
	LastRetry   sql.NullInt64  `json:"last_retry"`   // last_retry
	Retry       sql.NullInt64  `json:"retry"`        // retry

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the TractorEvent exists in the database.
func (te *TractorEvent) Exists() bool {
	return te._exists
}

// Deleted provides information if the TractorEvent has been deleted from the database.
func (te *TractorEvent) Deleted() bool {
	return te._deleted
}

// Insert inserts the TractorEvent to the database.
func (te *TractorEvent) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if te._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO "public"."tractor_events" (` +
		`"flow", "event_id", "event", "event_stamp", "source", "payload", "created_at", "from_service", "last_service", "last_error", "last_retry", "retry"` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12` +
		`) RETURNING "id"`

	// run query
	XOLog(sqlstr, te.Flow, te.EventID, te.Event, te.EventStamp, te.Source, te.Payload, te.CreatedAt, te.FromService, te.LastService, te.LastError, te.LastRetry, te.Retry)
	err = db.QueryRow(sqlstr, te.Flow, te.EventID, te.Event, te.EventStamp, te.Source, te.Payload, te.CreatedAt, te.FromService, te.LastService, te.LastError, te.LastRetry, te.Retry).Scan(&te.ID)
	if err != nil {
		return err
	}

	// set existence
	te._exists = true

	return nil
}

// Update updates the TractorEvent in the database.
func (te *TractorEvent) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !te._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if te._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE "public"."tractor_events" SET (` +
		`"flow", "event_id", "event", "event_stamp", "source", "payload", "created_at", "from_service", "last_service", "last_error", "last_retry", "retry"` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12` +
		`) WHERE "id" = $13`

	// run query
	XOLog(sqlstr, te.Flow, te.EventID, te.Event, te.EventStamp, te.Source, te.Payload, te.CreatedAt, te.FromService, te.LastService, te.LastError, te.LastRetry, te.Retry, te.ID)
	_, err = db.Exec(sqlstr, te.Flow, te.EventID, te.Event, te.EventStamp, te.Source, te.Payload, te.CreatedAt, te.FromService, te.LastService, te.LastError, te.LastRetry, te.Retry, te.ID)
	return err
}

// Save saves the TractorEvent to the database.
func (te *TractorEvent) Save(db XODB) error {
	if te.Exists() {
		return te.Update(db)
	}

	return te.Insert(db)
}

// Upsert performs an upsert for TractorEvent.
//
// NOTE: PostgreSQL 9.5+ only
func (te *TractorEvent) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if te._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "public"."tractor_events" (` +
		`"id", "flow", "event_id", "event", "event_stamp", "source", "payload", "created_at", "from_service", "last_service", "last_error", "last_retry", "retry"` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13` +
		`) ON CONFLICT ("id") DO UPDATE SET (` +
		`"id", "flow", "event_id", "event", "event_stamp", "source", "payload", "created_at", "from_service", "last_service", "last_error", "last_retry", "retry"` +
		`) = (` +
		`EXCLUDED."id", EXCLUDED."flow", EXCLUDED."event_id", EXCLUDED."event", EXCLUDED."event_stamp", EXCLUDED."source", EXCLUDED."payload", EXCLUDED."created_at", EXCLUDED."from_service", EXCLUDED."last_service", EXCLUDED."last_error", EXCLUDED."last_retry", EXCLUDED."retry"` +
		`)`

	// run query
	XOLog(sqlstr, te.ID, te.Flow, te.EventID, te.Event, te.EventStamp, te.Source, te.Payload, te.CreatedAt, te.FromService, te.LastService, te.LastError, te.LastRetry, te.Retry)
	_, err = db.Exec(sqlstr, te.ID, te.Flow, te.EventID, te.Event, te.EventStamp, te.Source, te.Payload, te.CreatedAt, te.FromService, te.LastService, te.LastError, te.LastRetry, te.Retry)
	if err != nil {
		return err
	}

	// set existence
	te._exists = true

	return nil
}

// Delete deletes the TractorEvent from the database.
func (te *TractorEvent) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !te._exists {
		return nil
	}

	// if deleted, bail
	if te._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "public"."tractor_events" WHERE "id" = $1`

	// run query
	XOLog(sqlstr, te.ID)
	_, err = db.Exec(sqlstr, te.ID)
	if err != nil {
		return err
	}

	// set deleted
	te._deleted = true

	return nil
}

// TractorEventsByCreatedAt retrieves a row from '"public"."tractor_events"' as a TractorEvent.
//
// Generated from index 'tractor_events_created_at'.
func TractorEventsByCreatedAt(db XODB, createdAt time.Time) ([]*TractorEvent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "flow", "event_id", "event", "event_stamp", "source", "payload", "created_at", "from_service", "last_service", "last_error", "last_retry", "retry" ` +
		`FROM "public"."tractor_events" ` +
		`WHERE "created_at" = $1`

	// run query
	XOLog(sqlstr, createdAt)
	q, err := db.Query(sqlstr, createdAt)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*TractorEvent{}
	for q.Next() {
		te := TractorEvent{
			_exists: true,
		}

		// scan
		err = q.Scan(&te.ID, &te.Flow, &te.EventID, &te.Event, &te.EventStamp, &te.Source, &te.Payload, &te.CreatedAt, &te.FromService, &te.LastService, &te.LastError, &te.LastRetry, &te.Retry)
		if err != nil {
			return nil, err
		}

		res = append(res, &te)
	}

	return res, nil
}

// TractorEventsByEventID retrieves a row from '"public"."tractor_events"' as a TractorEvent.
//
// Generated from index 'tractor_events_event_id'.
func TractorEventsByEventID(db XODB, eventID sql.NullString) ([]*TractorEvent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "flow", "event_id", "event", "event_stamp", "source", "payload", "created_at", "from_service", "last_service", "last_error", "last_retry", "retry" ` +
		`FROM "public"."tractor_events" ` +
		`WHERE "event_id" = $1`

	// run query
	XOLog(sqlstr, eventID)
	q, err := db.Query(sqlstr, eventID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*TractorEvent{}
	for q.Next() {
		te := TractorEvent{
			_exists: true,
		}

		// scan
		err = q.Scan(&te.ID, &te.Flow, &te.EventID, &te.Event, &te.EventStamp, &te.Source, &te.Payload, &te.CreatedAt, &te.FromService, &te.LastService, &te.LastError, &te.LastRetry, &te.Retry)
		if err != nil {
			return nil, err
		}

		res = append(res, &te)
	}

	return res, nil
}

// TractorEventsByEventStamp retrieves a row from '"public"."tractor_events"' as a TractorEvent.
//
// Generated from index 'tractor_events_event_stamp'.
func TractorEventsByEventStamp(db XODB, eventStamp pq.NullTime) ([]*TractorEvent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "flow", "event_id", "event", "event_stamp", "source", "payload", "created_at", "from_service", "last_service", "last_error", "last_retry", "retry" ` +
		`FROM "public"."tractor_events" ` +
		`WHERE "event_stamp" = $1`

	// run query
	XOLog(sqlstr, eventStamp)
	q, err := db.Query(sqlstr, eventStamp)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*TractorEvent{}
	for q.Next() {
		te := TractorEvent{
			_exists: true,
		}

		// scan
		err = q.Scan(&te.ID, &te.Flow, &te.EventID, &te.Event, &te.EventStamp, &te.Source, &te.Payload, &te.CreatedAt, &te.FromService, &te.LastService, &te.LastError, &te.LastRetry, &te.Retry)
		if err != nil {
			return nil, err
		}

		res = append(res, &te)
	}

	return res, nil
}

// TractorEventByID retrieves a row from '"public"."tractor_events"' as a TractorEvent.
//
// Generated from index 'tractor_events_pkey'.
func TractorEventByID(db XODB, id int64) (*TractorEvent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "flow", "event_id", "event", "event_stamp", "source", "payload", "created_at", "from_service", "last_service", "last_error", "last_retry", "retry" ` +
		`FROM "public"."tractor_events" ` +
		`WHERE "id" = $1`

	// run query
	XOLog(sqlstr, id)
	te := TractorEvent{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&te.ID, &te.Flow, &te.EventID, &te.Event, &te.EventStamp, &te.Source, &te.Payload, &te.CreatedAt, &te.FromService, &te.LastService, &te.LastError, &te.LastRetry, &te.Retry)
	if err != nil {
		return nil, err
	}

	return &te, nil
}

// XODB is the common interface for database operations that can be used with
// types from schema 'public'.
//
// This should work with database/sql.DB and database/sql.Tx.
type XODB interface {
	Exec(string, ...interface{}) (sql.Result, error)
	Query(string, ...interface{}) (*sql.Rows, error)
	QueryRow(string, ...interface{}) *sql.Row
}

// XOLog provides the log func used by generated queries.
var XOLog = func(string, ...interface{}) {}

// ScannerValuer is the common interface for types that implement both the
// database/sql.Scanner and sql/driver.Valuer interfaces.
type ScannerValuer interface {
	sql.Scanner
	driver.Valuer
}

// StringSlice is a slice of strings.
type StringSlice []string

// quoteEscapeRegex is the regex to match escaped characters in a string.
var quoteEscapeRegex = regexp.MustCompile(`([^\\]([\\]{2})*)\\"`)

// Scan satisfies the sql.Scanner interface for StringSlice.
func (ss *StringSlice) Scan(src interface{}) error {
	buf, ok := src.([]byte)
	if !ok {
		return errors.New("invalid StringSlice")
	}

	// change quote escapes for csv parser
	str := quoteEscapeRegex.ReplaceAllString(string(buf), `$1""`)
	str = strings.Replace(str, `\\`, `\`, -1)

	// remove braces
	str = str[1 : len(str)-1]

	// bail if only one
	if len(str) == 0 {
		*ss = StringSlice([]string{})
		return nil
	}

	// parse with csv reader
	cr := csv.NewReader(strings.NewReader(str))
	slice, err := cr.Read()
	if err != nil {
		fmt.Printf("exiting!: %v\n", err)
		return err
	}

	*ss = StringSlice(slice)

	return nil
}

// Value satisfies the driver.Valuer interface for StringSlice.
func (ss StringSlice) Value() (driver.Value, error) {
	v := make([]string, len(ss))
	for i, s := range ss {
		v[i] = `"` + strings.Replace(strings.Replace(s, `\`, `\\\`, -1), `"`, `\"`, -1) + `"`
	}
	return "{" + strings.Join(v, ",") + "}", nil
}

// Slice is a slice of ScannerValuers.
type Slice []ScannerValuer
