// Package dbo contains the types for schema 'public'.
package dbo

// Code generated by xo. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/csv"
	"errors"
	"fmt"
	"regexp"
	"strings"
	"time"
)

// TractorResult represents a row from '"tractor_result"'.
type TractorResult struct {
	ID            int64          `json:"id"`              // id
	Event         string         `json:"event"`           // event
	EventID       string         `json:"event_id"`        // event_id
	ParentEventID sql.NullString `json:"parent_event_id"` // parent_event_id
	StartedAt     time.Time      `json:"started_at"`      // started_at
	Input         []byte         `json:"input"`           // input
	FinishedAt    time.Time      `json:"finished_at"`     // finished_at
	Output        []byte         `json:"output"`          // output
	OutputEventID string         `json:"output_event_id"` // output_event_id
	JSONHeaders   string         `json:"json_headers"`    // json_headers
	Err           sql.NullString `json:"err"`             // err

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the TractorResult exists in the database.
func (tr *TractorResult) Exists() bool {
	return tr._exists
}

// Deleted provides information if the TractorResult has been deleted from the database.
func (tr *TractorResult) Deleted() bool {
	return tr._deleted
}

// Insert inserts the TractorResult to the database.
func (tr *TractorResult) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if tr._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO "tractor_result" (` +
		`"event", "event_id", "parent_event_id", "started_at", "input", "finished_at", "output", "output_event_id", "json_headers", "err"` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`) RETURNING "id"`

	// run query
	XOLog(sqlstr, tr.Event, tr.EventID, tr.ParentEventID, tr.StartedAt, tr.Input, tr.FinishedAt, tr.Output, tr.OutputEventID, tr.JSONHeaders, tr.Err)
	err = db.QueryRow(sqlstr, tr.Event, tr.EventID, tr.ParentEventID, tr.StartedAt, tr.Input, tr.FinishedAt, tr.Output, tr.OutputEventID, tr.JSONHeaders, tr.Err).Scan(&tr.ID)
	if err != nil {
		return err
	}

	// set existence
	tr._exists = true

	return nil
}

// Update updates the TractorResult in the database.
func (tr *TractorResult) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !tr._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if tr._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE "tractor_result" SET (` +
		`"event", "event_id", "parent_event_id", "started_at", "input", "finished_at", "output", "output_event_id", "json_headers", "err"` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`) WHERE "id" = $11`

	// run query
	XOLog(sqlstr, tr.Event, tr.EventID, tr.ParentEventID, tr.StartedAt, tr.Input, tr.FinishedAt, tr.Output, tr.OutputEventID, tr.JSONHeaders, tr.Err, tr.ID)
	_, err = db.Exec(sqlstr, tr.Event, tr.EventID, tr.ParentEventID, tr.StartedAt, tr.Input, tr.FinishedAt, tr.Output, tr.OutputEventID, tr.JSONHeaders, tr.Err, tr.ID)
	return err
}

// Save saves the TractorResult to the database.
func (tr *TractorResult) Save(db XODB) error {
	if tr.Exists() {
		return tr.Update(db)
	}

	return tr.Insert(db)
}

// Upsert performs an upsert for TractorResult.
//
// NOTE: PostgreSQL 9.5+ only
func (tr *TractorResult) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if tr._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO "tractor_result" (` +
		`"id", "event", "event_id", "parent_event_id", "started_at", "input", "finished_at", "output", "output_event_id", "json_headers", "err"` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11` +
		`) ON CONFLICT ("id") DO UPDATE SET (` +
		`"id", "event", "event_id", "parent_event_id", "started_at", "input", "finished_at", "output", "output_event_id", "json_headers", "err"` +
		`) = (` +
		`EXCLUDED."id", EXCLUDED."event", EXCLUDED."event_id", EXCLUDED."parent_event_id", EXCLUDED."started_at", EXCLUDED."input", EXCLUDED."finished_at", EXCLUDED."output", EXCLUDED."output_event_id", EXCLUDED."json_headers", EXCLUDED."err"` +
		`)`

	// run query
	XOLog(sqlstr, tr.ID, tr.Event, tr.EventID, tr.ParentEventID, tr.StartedAt, tr.Input, tr.FinishedAt, tr.Output, tr.OutputEventID, tr.JSONHeaders, tr.Err)
	_, err = db.Exec(sqlstr, tr.ID, tr.Event, tr.EventID, tr.ParentEventID, tr.StartedAt, tr.Input, tr.FinishedAt, tr.Output, tr.OutputEventID, tr.JSONHeaders, tr.Err)
	if err != nil {
		return err
	}

	// set existence
	tr._exists = true

	return nil
}

// Delete deletes the TractorResult from the database.
func (tr *TractorResult) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !tr._exists {
		return nil
	}

	// if deleted, bail
	if tr._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM "tractor_result" WHERE "id" = $1`

	// run query
	XOLog(sqlstr, tr.ID)
	_, err = db.Exec(sqlstr, tr.ID)
	if err != nil {
		return err
	}

	// set deleted
	tr._deleted = true

	return nil
}

// TractorResultsByEventID retrieves a row from '"tractor_result"' as a TractorResult.
//
// Generated from index 'tractor_result_event_id'.
func TractorResultsByEventID(db XODB, eventID string) ([]*TractorResult, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "event", "event_id", "parent_event_id", "started_at", "input", "finished_at", "output", "output_event_id", "json_headers", "err" ` +
		`FROM "tractor_result" ` +
		`WHERE "event_id" = $1`

	// run query
	XOLog(sqlstr, eventID)
	q, err := db.Query(sqlstr, eventID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*TractorResult{}
	for q.Next() {
		tr := TractorResult{
			_exists: true,
		}

		// scan
		err = q.Scan(&tr.ID, &tr.Event, &tr.EventID, &tr.ParentEventID, &tr.StartedAt, &tr.Input, &tr.FinishedAt, &tr.Output, &tr.OutputEventID, &tr.JSONHeaders, &tr.Err)
		if err != nil {
			return nil, err
		}

		res = append(res, &tr)
	}

	return res, nil
}

// TractorResultByID retrieves a row from '"tractor_result"' as a TractorResult.
//
// Generated from index 'tractor_result_pkey'.
func TractorResultByID(db XODB, id int64) (*TractorResult, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "event", "event_id", "parent_event_id", "started_at", "input", "finished_at", "output", "output_event_id", "json_headers", "err" ` +
		`FROM "tractor_result" ` +
		`WHERE "id" = $1`

	// run query
	XOLog(sqlstr, id)
	tr := TractorResult{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&tr.ID, &tr.Event, &tr.EventID, &tr.ParentEventID, &tr.StartedAt, &tr.Input, &tr.FinishedAt, &tr.Output, &tr.OutputEventID, &tr.JSONHeaders, &tr.Err)
	if err != nil {
		return nil, err
	}

	return &tr, nil
}

// TractorResultsByStartedAt retrieves a row from '"tractor_result"' as a TractorResult.
//
// Generated from index 'tractor_result_started_at'.
func TractorResultsByStartedAt(db XODB, startedAt time.Time) ([]*TractorResult, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`"id", "event", "event_id", "parent_event_id", "started_at", "input", "finished_at", "output", "output_event_id", "json_headers", "err" ` +
		`FROM "tractor_result" ` +
		`WHERE "started_at" = $1`

	// run query
	XOLog(sqlstr, startedAt)
	q, err := db.Query(sqlstr, startedAt)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*TractorResult{}
	for q.Next() {
		tr := TractorResult{
			_exists: true,
		}

		// scan
		err = q.Scan(&tr.ID, &tr.Event, &tr.EventID, &tr.ParentEventID, &tr.StartedAt, &tr.Input, &tr.FinishedAt, &tr.Output, &tr.OutputEventID, &tr.JSONHeaders, &tr.Err)
		if err != nil {
			return nil, err
		}

		res = append(res, &tr)
	}

	return res, nil
}

// XODB is the common interface for database operations that can be used with
// types from schema 'public'.
//
// This should work with database/sql.DB and database/sql.Tx.
type XODB interface {
	Exec(string, ...interface{}) (sql.Result, error)
	Query(string, ...interface{}) (*sql.Rows, error)
	QueryRow(string, ...interface{}) *sql.Row
}

// XOLog provides the log func used by generated queries.
var XOLog = func(string, ...interface{}) {}

// ScannerValuer is the common interface for types that implement both the
// database/sql.Scanner and sql/driver.Valuer interfaces.
type ScannerValuer interface {
	sql.Scanner
	driver.Valuer
}

// StringSlice is a slice of strings.
type StringSlice []string

// quoteEscapeRegex is the regex to match escaped characters in a string.
var quoteEscapeRegex = regexp.MustCompile(`([^\\]([\\]{2})*)\\"`)

// Scan satisfies the sql.Scanner interface for StringSlice.
func (ss *StringSlice) Scan(src interface{}) error {
	buf, ok := src.([]byte)
	if !ok {
		return errors.New("invalid StringSlice")
	}

	// change quote escapes for csv parser
	str := quoteEscapeRegex.ReplaceAllString(string(buf), `$1""`)
	str = strings.Replace(str, `\\`, `\`, -1)

	// remove braces
	str = str[1 : len(str)-1]

	// bail if only one
	if len(str) == 0 {
		*ss = StringSlice([]string{})
		return nil
	}

	// parse with csv reader
	cr := csv.NewReader(strings.NewReader(str))
	slice, err := cr.Read()
	if err != nil {
		fmt.Printf("exiting!: %v\n", err)
		return err
	}

	*ss = StringSlice(slice)

	return nil
}

// Value satisfies the driver.Valuer interface for StringSlice.
func (ss StringSlice) Value() (driver.Value, error) {
	v := make([]string, len(ss))
	for i, s := range ss {
		v[i] = `"` + strings.Replace(strings.Replace(s, `\`, `\\\`, -1), `"`, `\"`, -1) + `"`
	}
	return "{" + strings.Join(v, ",") + "}", nil
}

// Slice is a slice of ScannerValuers.
type Slice []ScannerValuer
